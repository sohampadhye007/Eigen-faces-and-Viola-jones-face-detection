# -*- coding: utf-8 -*-
"""M22RM007_Q1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jr30gUdUYTtYkM14x03TEsHB9oPheqLV

# Eigenfaces from scratch (M22RM007-Soham Padhye)
"""

# import necessary libraries
import cv2
from google.colab import drive
from google.colab.patches import cv2_imshow
import matplotlib.pyplot as plt
import os
import numpy as np
from sklearn.decomposition import PCA
from scipy.sparse.linalg import eigen

# mount Google Drive
drive.mount('/content/drive')

#Path for images, Added favourite sports person in the folder
dir_path = r"/content/drive/MyDrive/Asssignment-3/data/face-lfw-train/" 

# Set the dimensions for your resized images
width, height = 100, 100

#Define function for Normalizing all images
def Normalize_image(width, height,dir_path):
    # Create an empty list to store normalized images
    images = []

    # Loop through each file in the directory using os library function
    for file_name in os.listdir(dir_path):

        # Load the image using OpenCV
        img = cv2.imread(os.path.join(dir_path, file_name))

        # Resize the image to the desired dimensions
        img = cv2.resize(img, (width, height))

        # Convert the image to grayscale
        img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

        # Append the normalized image to your list of images
        images.append(img)
    print(f"Number of images in training set {len(images)}")

    # Convert the list of images to a NumPy array
    images = np.array(images)
    return images

images=Normalize_image(width, height,dir_path)

"""# Pre-rocessing the image"""

def preprocess(images):
    # Reshape the grayscale images to a 2D array
    num_images, height, width = images.shape
    flattened_images = images.reshape(num_images, height*width)
    print(f"Size of flattened image (gamma) {flattened_images.shape}")

    # Compute the mean image
    mean_image = np.mean(flattened_images, axis=0)
    print(f"Size of mean faces (psi) {mean_image.shape}")

    # Subtract the mean image from the flattened images
    centered_images = flattened_images - mean_image
    print(f"Size of phi {centered_images.shape}")

    return centered_images

centered_images=preprocess(images)

def pca_images(centered_images):
    # Apply PCA to the centered images
    num_components = 11
    pca = PCA(n_components=num_components)
    principal_components = pca.fit_transform(centered_images)

    # Compute the covariance matrix of the principal components
    covariance_matrix = np.cov(principal_components, rowvar=False)
    
    print(f"Size of covariance matrix {covariance_matrix.shape}")
    
    return covariance_matrix,pca

covariance_matrix,pca=pca_images(centered_images)

"""# Find Eigenvalues and Eigenvectors"""

def EigenValue_Eigenvector(covariance_matrix,centered_images):
    # Compute the eigenvectors and eigenvalues of the covariance matrix using SVD
    U, S, V = np.linalg.svd(covariance_matrix)

    # The eigenvectors are the columns of the matrix U
    eigenvectors = U
    print(eigenvectors[0])

    # The eigenvalues are the diagonal elements of the matrix S
    eigenvalues = S

    # Sort the eigenvalues and eigenvectors in descending order
    idx = np.argsort(eigenvalues)[::-1]
    eigenvalues = eigenvalues[idx]
    eigenvectors = eigenvectors[:, idx]
    print(eigenvectors.shape)

    # Compute the weights of each image on the Eigen faces
    weights = pca.transform(centered_images)
    return weights

weights=EigenValue_Eigenvector(covariance_matrix,centered_images)

"""# Loading test image for matching"""

dir_path = r"/content/drive/MyDrive/Asssignment-3/data/face-lfw-test/abd2.jpg" 
test_image = cv2.imread(dir_path,0)
cv2_imshow(test_image)
print(test_image.shape)

"""# Compute the Euclidean distance between the test image and the training images and find best match"""

#call preprocess function for preprocessing the test image in same way
centered_image_test=preprocess(images)

#Find weight of test image
test_image_weight = pca.transform(centered_image_test)

def matcher(weights,test_image_weight):
    
    #Find the distance beteen test image and other training images
    distances = np.linalg.norm(weights - test_image_weight, axis=1)

    # Get the indices of the closest matching images
    indices = np.argsort(distances)[:5]

    # Create a figure object with 5 subplots 
    fig, axes = plt.subplots(nrows=1, ncols=5, figsize=(20, 4))

    # Loop through each subplot and display the closest matching image
    for i, index in enumerate(indices[:5]):
        image = centered_images[index]
        #Resize matrix to get 2D image
        resized_matrix = image.reshape((100, 100))

        # Display the image 
        axes[i].imshow(resized_matrix, cmap='gray')
        plt.title('Matched faces')
        axes[i].axis('off')

    # Show the plot
    plt.show()
    
#Call Matcher function
matcher(weights,test_image_weight)

"""# Implementing without using PCA but using Matrix concept(A.AT....AT.A) used in original research paper- Eigenfaces for Recognition

"""

import os
import cv2
import numpy as np
import matplotlib.pyplot as plt

class FaceRecognizer:
    def __init__(self, train_path, test_path, num_eigenfaces):
        # Load the images
        train_files = os.listdir(train_path)
        self.train_images = []
        for file in train_files:
            img = cv2.imread(os.path.join(train_path, file), cv2.IMREAD_GRAYSCALE)
            img = cv2.resize(img, (100, 100))
            self.train_images.append(img)

        # Convert the list of images to a NumPy array
        self.train_images = np.array(self.train_images)

        # Reshape the grayscale images to a 2D array
        num_images, height, width = self.train_images.shape
        flattened_images = self.train_images.reshape(num_images, height*width)

        # Compute the mean image
        mean_image = np.mean(flattened_images, axis=0)
        plt.imshow(mean_image.reshape((height, width)))
        plt.title("Mean image")

        # Subtract the mean image from the flattened images
        centered_images = flattened_images - mean_image

        # Compute covariance matrix
        covariance_matrix = np.cov(centered_images)
        print(covariance_matrix.shape)

        # Compute eigenvalues and eigenvectors
        eigenvalues, eigenvectors = np.linalg.eig(covariance_matrix)
       
        eigenvectors=centered_images.T.dot(eigenvectors)

        # Sort the eigenvectors in descending order of eigenvalues
        idx = eigenvalues.argsort()[::-1]
        eigenvectors = eigenvectors[:, idx]

        # Normalize the eigenvectors
        for i in range(len(eigenvectors.T)):
            eigenvectors[:, i] /= np.linalg.norm(eigenvectors[:, i])

        # Select top k eigenfaces
        self.k = num_eigenfaces
        self.eigenfaces = eigenvectors[:, :self.k]

        # Project all images on the eigenfaces
        self.projected_faces = np.dot(self.eigenfaces.T, centered_images.T)

        # Save mean image and centered images
        self.mean_image = mean_image
        self.centered_images = centered_images

    def recognize_face(self, test_image_path):
        # Load test image
        test_img = cv2.imread(test_image_path, cv2.IMREAD_GRAYSCALE)
        test_img = cv2.resize(test_img, (100, 100))
        test_img_flat = test_img.flatten()
        test_img_flat = test_img_flat.flatten().astype(np.float64)
        test_img_flat -= self.mean_image

        # Project the test image on the eigenfaces
        projected_test_img = np.dot(self.eigenfaces.T, test_img_flat)

        # Compute distances between the projected faces and the projected test image
        distances = np.linalg.norm(self.projected_faces.T - projected_test_img, axis=1)

        # Find the index of the closest match
        min_distance_index = np.argmin(distances)

        # The recognized face is the one that has the minimum distance from the test image
        recognized_face = self.train_images[min_distance_index]

        return recognized_face

fr = FaceRecognizer(train_path='/content/drive/MyDrive/Asssignment-3/data/face-lfw-train',
                    test_path='/content/drive/MyDrive/Asssignment-3/data/face-lfw-test',
                    num_eigenfaces=11)
#Loading RCB cricket player ABD
test_image_path = '/content/drive/MyDrive/Asssignment-3/data/face-lfw-test/abd2.jpg'
recognized_image = fr.recognize_face(test_image_path)

# Display the test image and recognized image
fig, axes = plt.subplots(1, 2, figsize=(10, 5))

test_image = cv2.imread(test_image_path, cv2.IMREAD_GRAYSCALE)
test_image = cv2.resize(test_image, (100, 100))
axes[0].imshow(test_image)
axes[0].set_title('Test Image')

axes[1].imshow(recognized_image)
axes[1].set_title('Recognized Image')

plt.show()

"""# Find top K eigenfaces of the images"""

import os
import cv2
import numpy as np
from sklearn.decomposition import PCA
import matplotlib.pyplot as plt

class Eigenfaces:
    def __init__(self, num_components=10, train_folder=None, test_image_path=None):
        self.num_components = num_components
        self.train_folder = train_folder
        self.test_image_path = test_image_path
        self.images = []
        self.data = None
        self.img_height = None
        self.img_width = None
        self.pca = None
        self.eigenfaces = None
        self.test_image = None

    def load_images(self):
        for filename in os.listdir(self.train_folder):
            img = cv2.imread(os.path.join(self.train_folder, filename), cv2.IMREAD_GRAYSCALE)
            img = cv2.resize(img, (128, 128))
            if img is not None:
                self.images.append(img)
        self.data = np.array(self.images)
        num_images, self.img_height, self.img_width = self.data.shape
        self.data = self.data.reshape(num_images, self.img_height * self.img_width)
        self.data = (self.data - np.mean(self.data, axis=0)) / np.std(self.data, axis=0)

    def fit(self):
        self.pca = PCA(n_components=self.num_components)
        self.pca.fit(self.data)
        self.eigenfaces = self.pca.components_

    def test(self):
        self.test_image = cv2.imread(self.test_image_path, cv2.IMREAD_GRAYSCALE)
        self.test_image = cv2.resize(self.test_image, (128, 128))
        test_vector = self.test_image.flatten()
        normalized_test_vector = (test_vector - np.mean(test_vector)) / np.std(test_vector)
        projected_test_vector = self.pca.transform([normalized_test_vector])
        reconstructed_test_vector = self.pca.inverse_transform(projected_test_vector)
        reconstructed_test_image = reconstructed_test_vector.reshape(self.img_height, self.img_width)

        plt.imshow(self.test_image)
        plt.title('Test image')

        fig, axes = plt.subplots(1, self.num_components, figsize=(20, 10))

        for i in range(self.num_components):
            eigenface = self.eigenfaces[i].reshape(self.img_height, self.img_width)
            eigenface_normalized = cv2.normalize(eigenface, None, 0, 255, cv2.NORM_MINMAX)
            axes[i].imshow(eigenface_normalized.astype(np.uint8), cmap='gray')
            axes[i].set_xticks([])
            axes[i].set_yticks([])

        fig.suptitle('Top {} Eigenfaces'.format(self.num_components), fontsize=14, fontweight='bold')

        plt.show()


# Creating class instance
eigenfaces = Eigenfaces(num_components=10, train_folder='/content/drive/MyDrive/Asssignment-3/data/face-lfw-train', 
                        test_image_path='/content/drive/MyDrive/Asssignment-3/data/face-lfw-test/abd2.jpg')
eigenfaces.load_images()
eigenfaces.fit()
eigenfaces.test()

